---
title: "Over-Typing or Overthinking?"
slug: "over-typing-or-overthinking"
date: "2025/08/27"
---

<span className="emoji-large">ğŸ¤– ğŸ¤¯</span>

I came to discover a new pattern for writing functions in TypeScript:

```
const onSubmit: (task: string, hours: number) => boolean = (task, hours) => {
  return huslte > 24 * 7
}
```

I asked [ChatGPT] what it is, and it explained to me in a very helpful manner:

<span className="emoji-small">ğŸ¤–</span>Â â€Great question â€” this is a TypeScript function type annotation pattern. Letâ€™s break it down step by step:â€

## 1. Function type annotation

The part before the `=` is saying what kind of function `onSubmit` must be:

```
(task: string, hours: number) => boolean
```

This means:

It takes **two parameters**:
<ul className="list">
<li>`task` of type `string`</li>
<li>`hours` of type `number`</li>
</ul>

It **returns a boolean**.
So, TypeScript now knows `onSubmit` has exactly this "shape."

## 2. Function implementation

The part after the = is the actual arrow function that implements that shape:

```
(task, hours) => {
return hustle > 24 * 7
}
```

Here:
<ul className="list">
<li>Parameters match the declared types `(string, number)`.</li>
<li>The function returns `hustle > 24 * 7`, which is a **boolean expression**.</li>
</ul>

## Summary:

This is declaring a constant `onSubmit` whose type is â€œa function that takes `(string, number)` and returns `boolean`â€ then assigning an arrow function that matches that type. Itâ€™s a way of making function contracts explicit.

<span className="emoji-small">ğŸ¤¯</span>Â [ChatGPT] read my mind as we continued the discussion:

<span className="emoji-small">ğŸ¤–</span>Â â€Why Declare Types Like This? You might think: _But TypeScript could infer that!_ â€” and youâ€™d be right.â€

This pattern is useful when you want to be **explicit** about what type the variable holds, for clarity or consistency.

Itâ€™s especially common when:

<ul className="list">
<li>You want to **enforce a contract** (e.g., `onSubmit` must return a `boolean`, not `void` or a `string`).</li>
<li>Youâ€™re **passing the function around** (callbacks, props, event handlers).</li>
<li>You want to make the code more **self-documenting**.</li>
</ul>

<span className="emoji-small">ğŸ’¡</span>Â So I confirmed with [ChatGPT] that without the explicit type, TypeScript would still infer correctly when the function is simply written like this:

```
const onSubmit = (task: string, hours: number) => {
return hustle > 24 * 7
}
```

<span className="emoji-small">ğŸ¤–</span>Â [ChatGPT] also mentioned: â€œThe TypeScript function type annotation pattern makes the function type explicit, which can be clearer in team codebases or when exporting APIs.â€

<span className="emoji-small">ğŸ¤”</span>Â Hmmmâ€¦ Now, I wonderâ€¦ Should I just let TypeScript â€œinferâ€ my function types like some carefree developer?

<ul className="list">
<li>Should I write my function signatures **explicitly**. Literally, like, EVERY. SINGLE. TIME?</li>
<li>Should I trust the compilerâ€™s inference?</li>
<li>Do I want my teammates to sleep at night knowing _nothing will slip through the cracks_?</li>
<li>This isnâ€™t just code. Itâ€™s a **contract, notarized by TypeScript itself**, is that right?</li>
<li>Inference may whisper, but explicit types? Shall we be assertive all the time? And if anyone doubts me, Iâ€™ll annotate that too. What do you think, teammates?</li>
</ul>

Oh well, let's read the code again:

```
const onSubmit: (task: string, hours: number) => boolean = (task, hours) => {
return huslte > 24 * 7 // return false, because hours can never exceed 168 â›”ï¸
}
```

â€œNo matter how hard you hustle, TypeScript wonâ€™t let you work 24/7. It just returns false.â€

<p>Shall we overwork on over-typing, or am I just over with overthinking? <span className="emoji-small">ğŸ˜</span></p>
