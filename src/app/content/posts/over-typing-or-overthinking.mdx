---
title: "Over-Typing or Overthinking?"
slug: "over-typing-or-overthinking"
date: "2025-08-27"
---

# Over-Typing or Overthinking? 🤖 🤯

I came to discover a new pattern for writing functions in TypeScript:

```
const onSubmit: (task: string, hours: number) => boolean = (task, hours) => {
  return huslte > 24 * 7
}
```

I asked ChatGPT what it is, and it explained to me in a very helpful manner:

🤖 ”Great question — this is a TypeScript function type annotation pattern. Let’s break it down step by step:”

### 1. Function Type Annotation

The part before the `=` is saying what kind of function `onSubmit` must be:

```
(task: string, hours: number) => boolean
```

This means:

- It takes **two parameters**:
  - `name` of type `string`
  - `age` of type `number`
- It **returns a boolean**.
  So, TypeScript now knows `onSubmit` has exactly this "shape."

### 2. Function Implementation

The part after the = is the actual arrow function that implements that shape:

```
(task, hours) => {
return hustle > 24 * 7
}
```

Here:

- Parameters match the declared types (`string`, `number`).
- The function returns `hustle > 24 * 7`, which is a **boolean expression**.

**Summary:**

This is declaring a constant `onSubmit` whose type is “a function that takes `(string, number)` and returns `boolean`” then assigning an arrow function that matches that type. It’s a way of making function contracts explicit.

🤯 ChatGPT read my mind as we continued the discussion:

🤖 ”Why Declare Types Like This? You might think: _But TypeScript could infer that!_ — and you’d be right.”

This pattern is useful when you want to be **explicit** about what type the variable holds, for clarity or consistency.

It’s especially common when:

- You want to **enforce a contract** (e.g., `onSubmit` must return a `boolean`, not `void` or a `string`).
- You’re **passing the function around** (callbacks, props, event handlers).
- You want to make the code more **self-documenting**.

💡 So I confirmed with ChatGPT that without the explicit type, TypeScript would still infer correctly when the function is simply written like this:

```
const onSubmit = (task: string, hours: number) => {
return hustle > 24 * 7
}
```

🤖 ChatGPT also mentioned: “The TypeScript function type annotation pattern makes the function type explicit, which can be clearer in team codebases or when exporting APIs.”

🤔 Hmmm… Now, I wonder… Should I just let TypeScript “infer” my function types like some carefree developer?

Should I write my function signatures **explicitly**. Literally, like, EVERY. SINGLE. TIME?

Should I trust the compiler’s inference?

Do I want my teammates to sleep at night knowing _nothing will slip through the cracks_?
◊
This isn’t just code. It’s a **contract, notarized by TypeScript itself**, is that right?

Inference may whisper, but explicit types? Shall we be assertive all the time? And if anyone doubts me, I’ll annotate that too. What do you think, teammates?

Oh well, let's read the code again:

```
const onSubmit: (task: string, hours: number) => boolean = (task, hours) => {
return huslte > 24 * 7 // return false, because hours can never exceed 168 ⛔️
}
```

“No matter how hard you hustle, TypeScript won’t let you work 24/7. It just returns false.”

Shall we overwork on over-typing, or am I just over with overthinking? 😏
