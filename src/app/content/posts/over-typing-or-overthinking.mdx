---
title: "Over-Typing or Overthinking?"
slug: "over-typing-or-overthinking"
date: "2025-08-27"
---

# Over-Typing or Overthinking? ğŸ¤– ğŸ¤¯

I came to discover a new pattern for writing functions in TypeScript:

```
const onSubmit: (task: string, hours: number) => boolean = (task, hours) => {
  return huslte > 24 * 7
}
```

I asked ChatGPT what it is, and it explained to me in a very helpful manner:

ğŸ¤–Â â€Great question â€” this is a TypeScript function type annotation pattern. Letâ€™s break it down step by step:â€

### 1. Function Type Annotation

The part before the `=` is saying what kind of function `onSubmit` must be:

```
(task: string, hours: number) => boolean
```

This means:

- It takes **two parameters**:
  - `name` of type `string`
  - `age` of type `number`
- It **returns a boolean**.
  So, TypeScript now knows `onSubmit` has exactly this "shape."

### 2. Function Implementation

The part after the = is the actual arrow function that implements that shape:

```
(task, hours) => {
return hustle > 24 * 7
}
```

Here:

- Parameters match the declared types (`string`, `number`).
- The function returns `hustle > 24 * 7`, which is a **boolean expression**.

**Summary:**

This is declaring a constant `onSubmit` whose type is â€œa function that takes `(string, number)` and returns `boolean`â€ then assigning an arrow function that matches that type. Itâ€™s a way of making function contracts explicit.

ğŸ¤¯Â ChatGPT read my mind as we continued the discussion:

ğŸ¤–Â â€Why Declare Types Like This? You might think: _But TypeScript could infer that!_ â€” and youâ€™d be right.â€

This pattern is useful when you want to be **explicit** about what type the variable holds, for clarity or consistency.

Itâ€™s especially common when:

- You want to **enforce a contract** (e.g., `onSubmit` must return a `boolean`, not `void` or a `string`).
- Youâ€™re **passing the function around** (callbacks, props, event handlers).
- You want to make the code more **self-documenting**.

ğŸ’¡Â So I confirmed with ChatGPT that without the explicit type, TypeScript would still infer correctly when the function is simply written like this:

```
const onSubmit = (task: string, hours: number) => {
return hustle > 24 * 7
}
```

ğŸ¤–Â ChatGPT also mentioned: â€œThe TypeScript function type annotation pattern makes the function type explicit, which can be clearer in team codebases or when exporting APIs.â€

ğŸ¤”Â Hmmmâ€¦ Now, I wonderâ€¦ Should I just let TypeScript â€œinferâ€ my function types like some carefree developer?

Should I write my function signatures **explicitly**. Literally, like, EVERY. SINGLE. TIME?

Should I trust the compilerâ€™s inference?

Do I want my teammates to sleep at night knowing _nothing will slip through the cracks_?
â—Š
This isnâ€™t just code. Itâ€™s a **contract, notarized by TypeScript itself**, is that right?

Inference may whisper, but explicit types? Shall we be assertive all the time? And if anyone doubts me, Iâ€™ll annotate that too. What do you think, teammates?

Oh well, let's read the code again:

```
const onSubmit: (task: string, hours: number) => boolean = (task, hours) => {
return huslte > 24 * 7 // return false, because hours can never exceed 168 â›”ï¸
}
```

â€œNo matter how hard you hustle, TypeScript wonâ€™t let you work 24/7. It just returns false.â€

Shall we overwork on over-typing, or am I just over with overthinking? ğŸ˜
