---
title: "The JavaScript Kitchen (Part 2): When Async Goes Wrong"
slug: "javascript-kitchen-part-2"
date: "2025/11/10"
---

<span className="emoji-large">ğŸš«ğŸ•</span>

So, we've visited the JavaScript kitchen â€” one chef, one cutting board, and an event loop that keeps the orders flowing. But every kitchen has its bad days. Letâ€™s peek behind the swinging door and see what can go wrong when async chaos hits the restaurant.

## âš”ï¸ Race Condition: Waiters Gone Wild
Two waiters rush into the kitchen at the same time, both shouting,

â€œMy orderâ€™s ready first!â€

The chef panics, mixes ingredients from both plates, and sends out a weird combo no one ordered.

**In code:** Two async functions update the same variable, and whichever finishes first wins, unpredictably.

```
let sauce = "ğŸ…";
async function addCream() { sauce += "ğŸ¥›"; }
async function addSpice() { sauce += "ğŸŒ¶ï¸"; }

Promise.all([addCream(), addSpice()]).then(() => console.log(sauce));
// Output could be "ğŸ…ğŸ¥›ğŸŒ¶ï¸" or "ğŸ…ğŸŒ¶ï¸ğŸ¥›"
```
â¡ï¸ Lesson learned: When multiple async tasks touch shared state, lock the fridge or coordinate with await, mutexes, or queues.

## ğŸ§  Memory Leak: Never-Ending Leftovers
The chef keeps every used plate, spoon, and recipe in case theyâ€™re â€œneeded later.â€ Soon, the kitchen is buried under clutter, no space left to cook.

**In code:** References to unused data never get released.

```
const pantry = [];
function storeDish(dish) {
  pantry.push(dish); // never removed
}
```
â¡ï¸ Lesson learned: When listeners, caches, or closures hold references too long, the garbage collector canâ€™t clean up. Dispose what you donâ€™t need. Keep the kitchen clean.

## ğŸ¥˜ Blocking Code: The Chef Who Wonâ€™t Stop Stirring
While a timer rings and orders pile up, the chef insists on stirring soup for 5 hours.

**In code:**
```
// Synchronous CPU-heavy task
for (let i = 0; i < 1e9; i++) {} // blocks everything
console.log("Kitchen frozen ğŸ˜©");
```
## ğŸ§â€â™‚ï¸ Deadlock: Mutual Waiting Madness
The chef waits for the waiter to bring more ingredients.
The waiter waits for the chef to clear the board.
No one moves. Silence. Cold soup.

Deadlocks are rare in JS (thanks to the single-threaded model) but can appear in worker systems or external I/O dependencies.

â¡ï¸ Lesson learned: Avoid circular waits or interdependent promises.

## ğŸ‘¨â€ğŸ³ Too Many Chefs (Concurrency Confusion)
Each chef (Web Worker) has their own cutting board.
But without clear communication, they all shout across the kitchen.

â¡ï¸ Lesson learned: Workers canâ€™t share memory; they pass messages. Plan your inter-chef coordination carefully.

## ğŸ§¾ Final Bill

Every async â€œdisasterâ€ teaches one truth:

JavaScriptâ€™s power isnâ€™t multitasking â€” itâ€™s coordination.

Whether itâ€™s chefs, waiters, or timers, the kitchen only thrives when everyone knows **whoâ€™s waiting, whoâ€™s working, and whoâ€™s done.**